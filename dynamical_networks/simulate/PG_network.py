from __future__ import print_function, division

"""
Power-Grid Dynamical Network Simulation.
=======================================================================

This function simulates a Power-Grid (PG) dynamical network.
"""
def PG_steady_state(N, P, K):
    """ Find steady state solution for given network
        
    The default parameters are for the first example in the results section.
    """

    import numpy as np
    from scipy.optimize import minimize
    omega_ss = np.zeros((N,)) 
    theta_ss = np.zeros((N,)) 
    theta_ss = np.load('theta_ss.npy')
    def cost_function(theta_ss):
        cost = []
        for i in range(N):
            cost_i = P[i]
            for j in range(N):
                cost_i += K[i][j]*np.sin(theta_ss[j] - theta_ss[i])
            cost.append(cost_i)
        print(np.sum(np.array(cost)**2))
        return np.sum(np.array(cost)**2)
    res = minimize(cost_function, x0 = theta_ss, method='BFGS')
    theta_ss = res.x
    np.save('theta_ss', theta_ss)
    return theta_ss, omega_ss
    
def PG_flows(theta, omega, K, N):
    """ Calculates flows from theta and omega of steady state
    """
    import numpy as np
    F = np.zeros((N,N))
    for i in range(N):
        for j in range(N):
            F[i][j] = K[i][j]*np.sin(theta[j] - theta[i])
    return F

def get_edge_list(A):
    """ From adjacency matrix go to list of edges.
    """
    import numpy as np
    A_ut = np.triu(A)
    E = []
    for i in range(len(A_ut)):
        for j in range(len(A_ut[i])):
            if A_ut[i][j] != 0:
                E.append([i,j])
    return np.array(E)
    
def PG_network(A, t, V_gen, V_con, K_0 = 1.63, P_gen = 1.5, P_con = 1, alpha = 0.6, I_0 = 1,
                  damping = 0.5, e_cut = (2,4), ss = None):
    """This function simulates and returns a power grids network through the adjacency matrix over time t.

    Args:
       t (array): time array

    Kwargs:
       plotting (bool): Plotting for user interpretation. defaut is False.

    Returns:
       (matrix): A, an n by n matrix A over time t.

    """
    
    import networkx as nx
    import numpy as np

    A_0 = np.copy(A) #use copy of adjacency matrix for plotting all the flows
    A_0[A_0>0] = 1
    E = get_edge_list(A)

    def swing_equation(omega, theta):
        d_theta, d_omega = np.zeros((N,)), np.zeros((N,))
        for i in range(N):
            d_theta[i] = omega[i]
            d_omega[i] = P[i] - G[i]*omega[i]
            for j in range(N):
                d_omega[i] = d_omega[i] + K[i][j]*np.sin(theta[j] - theta[i])
                #I believe the authors used A[i][j] here instead of K[i][j] as they state in their equations.
            d_omega[i] = d_omega[i]/I[i]
        return d_theta, d_omega
    
    
    G = nx.convert_matrix.from_numpy_matrix(A)
    N = G.number_of_nodes()
    
    P = np.zeros((N,)) 
    P[V_gen] = P_gen
    P[V_con] = -P_con
    
    K = K_0*A_0
    I = np.zeros((N,)) + I_0 #inertia of power generators
    G = np.zeros((N,)) + damping #damping of rotary machine
    C = alpha*K
    
    
    
    #get new steady state values
    
    if ss == None:
        theta, omega = PG_steady_state(N, P, K)
    else:
        theta, omega = ss[0], ss[1]
        
        
    Fs = []
    dt = t[1]-t[0]
    t_step = 0
    for t_i in t:
        t_step += dt
        if t_step > 0.25:
            print(np.round(t_i,2))
            t_step = 0
        if t_i > 1: # remove line 4-2 at 1 second
            K[e_cut[0]][e_cut[1]], K[e_cut[1]][e_cut[0]] = 0, 0
            
        d_theta, d_omega = swing_equation(omega, theta)
        theta, omega = theta+d_theta*dt, omega+d_omega*dt
        F = PG_flows(theta, omega, K, N)
        
        for e in E:
            if np.abs(F[e[0],e[1]]) > C[e[0],e[1]]: # if flow is greater than line capacity
                K[e[0]][e[1]], K[e[1]][e[0]] = 0, 0
            
        flows = []
        for e in E:
            flows.append(np.abs(F[e[0], e[1]]))
        Fs.append(flows)
        
    Fs = np.array(Fs).T  
    
    return Fs, E


# In[ ]:


if __name__ == '__main__':
    #from dynamical_networks.simulate.PG_network import PG_network
    
    import matplotlib.pyplot as plt
    import numpy as np
    import networkx as nx
    
    t = np.linspace(0,12, 5000) #the time which the simulation will be solved for.
    P_gen = 1.5 #the amount of power generated by the generators.
    P_con = 1 #the power consumed by the consumers.
    K_0 = 1.63 #the capacitance of the lines
    I_0 = 1 #inertia of the power generators and consumers
    damping = 0.5 #the damping in the power oscillations or losses in the transmission of power.
    alpha = 0.6 #a factor of safety for for the capacity of the power lines
    V_gen = np.array([1, 4]) #vertices indices of generates
    V_con = np.array([0, 2, 3]) #vertices indices of consumers
    A = np.array([[0, 1, 1, 0, 1],
                  [1, 0, 1, 1, 0],
                  [1, 1, 0, 1, 0],
                  [0, 1, 1, 0, 1],
                  [1, 0, 0, 1, 0]])
    
    
    
    
    
    
    
    
    t = np.linspace(0,10, 5000) #the time which the simulation will be solved for.
    K_0 = 5 #the capacitance of the lines
    P_gen = 1 #the amount of power generated by the generators.
    P_con = 1 #the power consumed by the consumers.
    I_0 = 1 #inertia of the power generators and consumers
    damping = 0.1 #the damping in the power oscillations or losses in the transmission of power.
    alpha = 0.6 #a factor of safety for for the capacity of the power lines
    from numpy import genfromtxt
    A = genfromtxt('power_grid_data\\SpanishHeterogeneousCoupling_Matrix.csv', delimiter=',')
    power_assignment = genfromtxt('power_grid_data\\SpanishHeterogeneousCoupling_Power.csv', delimiter=',')
    V_gen = np.argwhere(power_assignment > 0).T[0] #vertices indices of generates
    V_con = np.argwhere(power_assignment < 0).T[0] #vertices indices of consumers
    theta_ss = np.load('theta_ss_spanish.npy')
    omega_ss = np.zeros((len(theta_ss),))
    ss = [theta_ss, omega_ss]
    #cut = (16, 19) #high cost
    cut = (56, 58) #highest cost?
    #cut = (16, 18) #low cost



    

    
    G = nx.convert_matrix.from_numpy_matrix(A) #create a graph from adjacency matrix
    pos = nx.spring_layout(G, k = 0.2, iterations = 10000) #define positions for visualization purposes
    color_map = [] #define colors based on generator or consumers
    for node in G:
        if node in V_gen:
            color_map.append('green')
        else: 
            color_map.append('red') 
    plt.figure(figsize = (10,10))
    nx.draw(G, pos, node_color = color_map, width = 1, with_labels = True) #draw the graph
    plt.show()
    
    
    Fs, E = PG_network(A, t, V_gen, V_con, K_0, P_gen, P_con, alpha, I_0, damping, e_cut = cut, ss = ss)
    
    

# In[ ]:

    #---------------PLOTTING-------------------
    
    plt.figure(figsize = (10,5))
    TextSize = 20
    for i in range(len(Fs)):
        plt.plot(t, Fs[i], label = '$('+str(E[i][0])+','+str(E[i][1])+')$')
        print('('+str(E[i][0])+','+str(E[i][1])+')  -  ', Fs[i][0])
    plt.plot([0,max(t)], [alpha*K_0, alpha*K_0], 'k--')
    
    plt.grid()
    plt.xlim(0,max(t))
    plt.ylim(0,)
    plt.xticks(size = TextSize)
    plt.yticks(size = TextSize)
    plt.xlabel(r'$t$', size = TextSize)
    plt.ylabel(r'$|F_{i,j}|$', size = TextSize)
    #plt.legend(loc = 'upper right', fontsize = TextSize-12, ncol = 1)
    plt.show()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    